public static void interpolateBoard(int x, int y) {
        Point currentPoint = new Point(x,y);
        Point destinationPoint = new Point(lastX,lastY);
        Boolean[][] visitedCells = new Boolean[boardSize][boardSize];
        List<Point> currentPath = new ArrayList<Point>();
        List<Point> shortestPath = new ArrayList<Point>();
        recursiveFindShortestDistance(currentPoint,destinationPoint,visitedCells,currentPath,shortestPath);

        for (int i = 0; i < boardSize; i++) {
            for (int j = 0; j < boardSize; j++) {
                visitedCells[i][j] = false;
            }
        }
        for (Point variable : shortestPath){
            Board[variable.getX()][variable.getY()] = current_color_node;

        }
        Main.frame.repaint();
    }
    public static void recursiveFindShortestDistance(Point currentCell, Point destinationCell, Boolean[][] visitedCells, List<Point> currentPath, List<Point> shortestPath){
        visitedCells[currentCell.getX()][currentCell.getY()] = true;
        currentPath.add(currentCell);

        if (currentCell.getX() == destinationCell.getX() && currentCell.getY() == destinationCell.getY()){
            if(shortestPath.isEmpty() || currentPath.size()< shortestPath.size()){
                shortestPath.clear();
                shortestPath.addAll(currentPath);
            }
        }else {
            int[] dx = {-1, 0, 1, 0};
            int[] dy = {0, 1, 0, -1};
            for (int i = 0; i < 4; i++) {
                int nextX = currentCell.getX() + dx[i];
                int nextY = currentCell.getY() + dy[i];
                if (nextX >= 0 && nextX < boardSize && nextY >= 0 && nextY < boardSize && !visitedCells[nextX][nextY]) {
                    recursiveFindShortestDistance(new Point(nextX, nextY), destinationCell, visitedCells, currentPath, shortestPath);
                }
            }
        }
        visitedCells[currentCell.getX()][currentCell.getY()] = false;
        currentPath.remove(currentPath.size() - 1);

    }



    public static void fillGap(int x, int y) {


            List<Integer> gapLocations = new ArrayList<>();

            boolean[][] visited = new boolean[boardSize][boardSize];
            if (Board[x][y] != current_color_node) {
                List<Point> hole = measureHole(x,y, visited);
                for (Point p : hole){
                    Board[p.getX()][p.getY()] = current_color_node;
                }

            }

        }


        private static List<Point> measureHole(int x, int y, boolean[][] visited) {
            List<Point> drawPositions = new ArrayList<Point>();




            if (x < 0 || x >= boardSize || y < 0 || y >= boardSize || Board[x][y].compareColors(current_color_node) ) {
                return drawPositions;
            }
            visited[x][y] = true;



            drawPositions.addAll(measureHole(x - 1, y, visited));
            drawPositions.addAll(measureHole(x + 1, y, visited));
            drawPositions.addAll(measureHole(x, y+1, visited));
            drawPositions.addAll(measureHole(x, y-1, visited));

            Point point = new Point(x,y);
            drawPositions.add(point);

            return drawPositions;
        }